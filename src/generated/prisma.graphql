input AddressCreateInput {
  id: ID
  city: String
  country: String
  postalCode: String
  state: String
  streetAddress: String
  additionalStreetAddress: String
  associatedUser: UserCreateOneWithoutAddressInput
}

input AddressCreateOneWithoutAssociatedUserInput {
  create: AddressCreateWithoutAssociatedUserInput
  connect: AddressWhereUniqueInput
}

input AddressCreateWithoutAssociatedUserInput {
  id: ID
  city: String
  country: String
  postalCode: String
  state: String
  streetAddress: String
  additionalStreetAddress: String
}

type AddressPreviousValues {
  id: ID!
  city: String!
  country: String!
  postalCode: String!
  state: String!
  streetAddress: String!
  additionalStreetAddress: String!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  # Logical AND on all given filters.
  AND: [AddressSubscriptionWhereInput!]

  # Logical OR on all given filters.
  OR: [AddressSubscriptionWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [AddressSubscriptionWhereInput!]

  # The subscription event gets dispatched when it's listed in mutation_in
  mutation_in: [MutationType!]

  # The subscription event gets only dispatched when one of the updated fields names is included in this list
  updatedFields_contains: String

  # The subscription event gets only dispatched when all of the field names included in this list have been updated
  updatedFields_contains_every: [String!]

  # The subscription event gets only dispatched when some of the field names included in this list have been updated
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
}

input AddressUpdateInput {
  city: String
  country: String
  postalCode: String
  state: String
  streetAddress: String
  additionalStreetAddress: String
  associatedUser: UserUpdateOneWithoutAddressInput
}

input AddressUpdateManyMutationInput {
  city: String
  country: String
  postalCode: String
  state: String
  streetAddress: String
  additionalStreetAddress: String
}

input AddressUpdateOneWithoutAssociatedUserInput {
  create: AddressCreateWithoutAssociatedUserInput
  connect: AddressWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AddressUpdateWithoutAssociatedUserDataInput
  upsert: AddressUpsertWithoutAssociatedUserInput
}

input AddressUpdateWithoutAssociatedUserDataInput {
  city: String
  country: String
  postalCode: String
  state: String
  streetAddress: String
  additionalStreetAddress: String
}

input AddressUpsertWithoutAssociatedUserInput {
  update: AddressUpdateWithoutAssociatedUserDataInput!
  create: AddressCreateWithoutAssociatedUserInput!
}

#
type BatchPayload {
  # The number of nodes that have been affected by the Batch operation.
  count: Long!
}

input CartCreateInput {
  id: ID
  price: Int!
  products: ProductCreateManyWithoutCartsInput
  relatedUser: UserCreateOneWithoutCartInput
}

input CartCreateManyWithoutProductsInput {
  create: [CartCreateWithoutProductsInput!]
  connect: [CartWhereUniqueInput!]
}

input CartCreateOneWithoutRelatedUserInput {
  create: CartCreateWithoutRelatedUserInput
  connect: CartWhereUniqueInput
}

input CartCreateWithoutProductsInput {
  id: ID
  price: Int!
  relatedUser: UserCreateOneWithoutCartInput
}

input CartCreateWithoutRelatedUserInput {
  id: ID
  price: Int!
  products: ProductCreateManyWithoutCartsInput
}

type CartPreviousValues {
  id: ID!
  price: Int!
}

input CartScalarWhereInput {
  # Logical AND on all given filters.
  AND: [CartScalarWhereInput!]

  # Logical OR on all given filters.
  OR: [CartScalarWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [CartScalarWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int
}

type CartSubscriptionPayload {
  mutation: MutationType!
  node: Cart
  updatedFields: [String!]
  previousValues: CartPreviousValues
}

input CartSubscriptionWhereInput {
  # Logical AND on all given filters.
  AND: [CartSubscriptionWhereInput!]

  # Logical OR on all given filters.
  OR: [CartSubscriptionWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [CartSubscriptionWhereInput!]

  # The subscription event gets dispatched when it's listed in mutation_in
  mutation_in: [MutationType!]

  # The subscription event gets only dispatched when one of the updated fields names is included in this list
  updatedFields_contains: String

  # The subscription event gets only dispatched when all of the field names included in this list have been updated
  updatedFields_contains_every: [String!]

  # The subscription event gets only dispatched when some of the field names included in this list have been updated
  updatedFields_contains_some: [String!]
  node: CartWhereInput
}

input CartUpdateInput {
  price: Int
  products: ProductUpdateManyWithoutCartsInput
  relatedUser: UserUpdateOneWithoutCartInput
}

input CartUpdateManyDataInput {
  price: Int
}

input CartUpdateManyMutationInput {
  price: Int
}

input CartUpdateManyWithWhereNestedInput {
  where: CartScalarWhereInput!
  data: CartUpdateManyDataInput!
}

input CartUpdateManyWithoutProductsInput {
  create: [CartCreateWithoutProductsInput!]
  connect: [CartWhereUniqueInput!]
  set: [CartWhereUniqueInput!]
  disconnect: [CartWhereUniqueInput!]
  delete: [CartWhereUniqueInput!]
  update: [CartUpdateWithWhereUniqueWithoutProductsInput!]
  updateMany: [CartUpdateManyWithWhereNestedInput!]
  deleteMany: [CartScalarWhereInput!]
  upsert: [CartUpsertWithWhereUniqueWithoutProductsInput!]
}

input CartUpdateOneWithoutRelatedUserInput {
  create: CartCreateWithoutRelatedUserInput
  connect: CartWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CartUpdateWithoutRelatedUserDataInput
  upsert: CartUpsertWithoutRelatedUserInput
}

input CartUpdateWithWhereUniqueWithoutProductsInput {
  where: CartWhereUniqueInput!
  data: CartUpdateWithoutProductsDataInput!
}

input CartUpdateWithoutProductsDataInput {
  price: Int
  relatedUser: UserUpdateOneWithoutCartInput
}

input CartUpdateWithoutRelatedUserDataInput {
  price: Int
  products: ProductUpdateManyWithoutCartsInput
}

input CartUpsertWithWhereUniqueWithoutProductsInput {
  where: CartWhereUniqueInput!
  update: CartUpdateWithoutProductsDataInput!
  create: CartCreateWithoutProductsInput!
}

input CartUpsertWithoutRelatedUserInput {
  update: CartUpdateWithoutRelatedUserDataInput!
  create: CartCreateWithoutRelatedUserInput!
}

# Raw JSON value
scalar Json

type Mutation {
  createUser(data: UserCreateInput!): User!
  createProduct(data: ProductCreateInput!): Product!
  createOrder(data: OrderCreateInput!): Order!
  createCart(data: CartCreateInput!): Cart!
  createAddress(data: AddressCreateInput!): Address!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateProduct(
    data: ProductUpdateInput!
    where: ProductWhereUniqueInput!
  ): Product
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateCart(data: CartUpdateInput!, where: CartWhereUniqueInput!): Cart
  updateAddress(
    data: AddressUpdateInput!
    where: AddressWhereUniqueInput!
  ): Address
  deleteUser(where: UserWhereUniqueInput!): User
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteCart(where: CartWhereUniqueInput!): Cart
  deleteAddress(where: AddressWhereUniqueInput!): Address
  upsertUser(
    where: UserWhereUniqueInput!
    create: UserCreateInput!
    update: UserUpdateInput!
  ): User!
  upsertProduct(
    where: ProductWhereUniqueInput!
    create: ProductCreateInput!
    update: ProductUpdateInput!
  ): Product!
  upsertOrder(
    where: OrderWhereUniqueInput!
    create: OrderCreateInput!
    update: OrderUpdateInput!
  ): Order!
  upsertCart(
    where: CartWhereUniqueInput!
    create: CartCreateInput!
    update: CartUpdateInput!
  ): Cart!
  upsertAddress(
    where: AddressWhereUniqueInput!
    create: AddressCreateInput!
    update: AddressUpdateInput!
  ): Address!
  updateManyUsers(
    data: UserUpdateManyMutationInput!
    where: UserWhereInput
  ): BatchPayload!
  updateManyProducts(
    data: ProductUpdateManyMutationInput!
    where: ProductWhereInput
  ): BatchPayload!
  updateManyOrders(
    data: OrderUpdateManyMutationInput!
    where: OrderWhereInput
  ): BatchPayload!
  updateManyCarts(
    data: CartUpdateManyMutationInput!
    where: CartWhereInput
  ): BatchPayload!
  updateManyAddresses(
    data: AddressUpdateManyMutationInput!
    where: AddressWhereInput
  ): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  deleteManyCarts(where: CartWhereInput): BatchPayload!
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  executeRaw(database: PrismaDatabase, query: String!): Json!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

input OrderCreateInput {
  id: ID
  price: Int!
  date: DateTime!
  status: OrderStatus
  associatedUser: UserCreateOneWithoutOrdersInput
  products: ProductCreateManyWithoutOrdersInput
}

input OrderCreateManyWithoutAssociatedUserInput {
  create: [OrderCreateWithoutAssociatedUserInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutProductsInput {
  create: [OrderCreateWithoutProductsInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateWithoutAssociatedUserInput {
  id: ID
  price: Int!
  date: DateTime!
  status: OrderStatus
  products: ProductCreateManyWithoutOrdersInput
}

input OrderCreateWithoutProductsInput {
  id: ID
  price: Int!
  date: DateTime!
  status: OrderStatus
  associatedUser: UserCreateOneWithoutOrdersInput
}

type OrderPreviousValues {
  id: ID!
  price: Int!
  date: DateTime!
  status: OrderStatus!
}

input OrderScalarWhereInput {
  # Logical AND on all given filters.
  AND: [OrderScalarWhereInput!]

  # Logical OR on all given filters.
  OR: [OrderScalarWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [OrderScalarWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int

  #
  date: DateTime

  # All values that are not equal to given value.
  date_not: DateTime

  # All values that are contained in given list.
  date_in: [DateTime!]

  # All values that are not contained in given list.
  date_not_in: [DateTime!]

  # All values less than the given value.
  date_lt: DateTime

  # All values less than or equal the given value.
  date_lte: DateTime

  # All values greater than the given value.
  date_gt: DateTime

  # All values greater than or equal the given value.
  date_gte: DateTime

  #
  status: OrderStatus

  # All values that are not equal to given value.
  status_not: OrderStatus

  # All values that are contained in given list.
  status_in: [OrderStatus!]

  # All values that are not contained in given list.
  status_not_in: [OrderStatus!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  # Logical AND on all given filters.
  AND: [OrderSubscriptionWhereInput!]

  # Logical OR on all given filters.
  OR: [OrderSubscriptionWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [OrderSubscriptionWhereInput!]

  # The subscription event gets dispatched when it's listed in mutation_in
  mutation_in: [MutationType!]

  # The subscription event gets only dispatched when one of the updated fields names is included in this list
  updatedFields_contains: String

  # The subscription event gets only dispatched when all of the field names included in this list have been updated
  updatedFields_contains_every: [String!]

  # The subscription event gets only dispatched when some of the field names included in this list have been updated
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
}

input OrderUpdateInput {
  price: Int
  date: DateTime
  status: OrderStatus
  associatedUser: UserUpdateOneWithoutOrdersInput
  products: ProductUpdateManyWithoutOrdersInput
}

input OrderUpdateManyDataInput {
  price: Int
  date: DateTime
  status: OrderStatus
}

input OrderUpdateManyMutationInput {
  price: Int
  date: DateTime
  status: OrderStatus
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateManyWithoutAssociatedUserInput {
  create: [OrderCreateWithoutAssociatedUserInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  delete: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutAssociatedUserInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
  deleteMany: [OrderScalarWhereInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutAssociatedUserInput!]
}

input OrderUpdateManyWithoutProductsInput {
  create: [OrderCreateWithoutProductsInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  delete: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutProductsInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
  deleteMany: [OrderScalarWhereInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutProductsInput!]
}

input OrderUpdateWithWhereUniqueWithoutAssociatedUserInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutAssociatedUserDataInput!
}

input OrderUpdateWithWhereUniqueWithoutProductsInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutProductsDataInput!
}

input OrderUpdateWithoutAssociatedUserDataInput {
  price: Int
  date: DateTime
  status: OrderStatus
  products: ProductUpdateManyWithoutOrdersInput
}

input OrderUpdateWithoutProductsDataInput {
  price: Int
  date: DateTime
  status: OrderStatus
  associatedUser: UserUpdateOneWithoutOrdersInput
}

input OrderUpsertWithWhereUniqueWithoutAssociatedUserInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutAssociatedUserDataInput!
  create: OrderCreateWithoutAssociatedUserInput!
}

input OrderUpsertWithWhereUniqueWithoutProductsInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutProductsDataInput!
  create: OrderCreateWithoutProductsInput!
}

enum PrismaDatabase {
  default
}

input ProductCreateInput {
  id: ID
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
  orders: OrderCreateManyWithoutProductsInput
  submittedBy: UserCreateOneWithoutProductsInput
  validatedBy: UserCreateOneWithoutValidatedProductsInput
  carts: CartCreateManyWithoutProductsInput
}

input ProductCreateManyWithoutCartsInput {
  create: [ProductCreateWithoutCartsInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutOrdersInput {
  create: [ProductCreateWithoutOrdersInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutSubmittedByInput {
  create: [ProductCreateWithoutSubmittedByInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutValidatedByInput {
  create: [ProductCreateWithoutValidatedByInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateWithoutCartsInput {
  id: ID
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
  orders: OrderCreateManyWithoutProductsInput
  submittedBy: UserCreateOneWithoutProductsInput
  validatedBy: UserCreateOneWithoutValidatedProductsInput
}

input ProductCreateWithoutOrdersInput {
  id: ID
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
  submittedBy: UserCreateOneWithoutProductsInput
  validatedBy: UserCreateOneWithoutValidatedProductsInput
  carts: CartCreateManyWithoutProductsInput
}

input ProductCreateWithoutSubmittedByInput {
  id: ID
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
  orders: OrderCreateManyWithoutProductsInput
  validatedBy: UserCreateOneWithoutValidatedProductsInput
  carts: CartCreateManyWithoutProductsInput
}

input ProductCreateWithoutValidatedByInput {
  id: ID
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
  orders: OrderCreateManyWithoutProductsInput
  submittedBy: UserCreateOneWithoutProductsInput
  carts: CartCreateManyWithoutProductsInput
}

type ProductPreviousValues {
  id: ID!
  name: String!
  price: Int!
  status: ProductStatus
  description: String!
}

input ProductScalarWhereInput {
  # Logical AND on all given filters.
  AND: [ProductScalarWhereInput!]

  # Logical OR on all given filters.
  OR: [ProductScalarWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [ProductScalarWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  name: String

  # All values that are not equal to given value.
  name_not: String

  # All values that are contained in given list.
  name_in: [String!]

  # All values that are not contained in given list.
  name_not_in: [String!]

  # All values less than the given value.
  name_lt: String

  # All values less than or equal the given value.
  name_lte: String

  # All values greater than the given value.
  name_gt: String

  # All values greater than or equal the given value.
  name_gte: String

  # All values containing the given string.
  name_contains: String

  # All values not containing the given string.
  name_not_contains: String

  # All values starting with the given string.
  name_starts_with: String

  # All values not starting with the given string.
  name_not_starts_with: String

  # All values ending with the given string.
  name_ends_with: String

  # All values not ending with the given string.
  name_not_ends_with: String

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int

  #
  status: ProductStatus

  # All values that are not equal to given value.
  status_not: ProductStatus

  # All values that are contained in given list.
  status_in: [ProductStatus!]

  # All values that are not contained in given list.
  status_not_in: [ProductStatus!]

  #
  description: String

  # All values that are not equal to given value.
  description_not: String

  # All values that are contained in given list.
  description_in: [String!]

  # All values that are not contained in given list.
  description_not_in: [String!]

  # All values less than the given value.
  description_lt: String

  # All values less than or equal the given value.
  description_lte: String

  # All values greater than the given value.
  description_gt: String

  # All values greater than or equal the given value.
  description_gte: String

  # All values containing the given string.
  description_contains: String

  # All values not containing the given string.
  description_not_contains: String

  # All values starting with the given string.
  description_starts_with: String

  # All values not starting with the given string.
  description_not_starts_with: String

  # All values ending with the given string.
  description_ends_with: String

  # All values not ending with the given string.
  description_not_ends_with: String
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  # Logical AND on all given filters.
  AND: [ProductSubscriptionWhereInput!]

  # Logical OR on all given filters.
  OR: [ProductSubscriptionWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [ProductSubscriptionWhereInput!]

  # The subscription event gets dispatched when it's listed in mutation_in
  mutation_in: [MutationType!]

  # The subscription event gets only dispatched when one of the updated fields names is included in this list
  updatedFields_contains: String

  # The subscription event gets only dispatched when all of the field names included in this list have been updated
  updatedFields_contains_every: [String!]

  # The subscription event gets only dispatched when some of the field names included in this list have been updated
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
}

input ProductUpdateInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
  orders: OrderUpdateManyWithoutProductsInput
  submittedBy: UserUpdateOneWithoutProductsInput
  validatedBy: UserUpdateOneWithoutValidatedProductsInput
  carts: CartUpdateManyWithoutProductsInput
}

input ProductUpdateManyDataInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
}

input ProductUpdateManyMutationInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateManyWithoutCartsInput {
  create: [ProductCreateWithoutCartsInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  delete: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCartsInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  deleteMany: [ProductScalarWhereInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCartsInput!]
}

input ProductUpdateManyWithoutOrdersInput {
  create: [ProductCreateWithoutOrdersInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  delete: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutOrdersInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  deleteMany: [ProductScalarWhereInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutOrdersInput!]
}

input ProductUpdateManyWithoutSubmittedByInput {
  create: [ProductCreateWithoutSubmittedByInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  delete: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutSubmittedByInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  deleteMany: [ProductScalarWhereInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutSubmittedByInput!]
}

input ProductUpdateManyWithoutValidatedByInput {
  create: [ProductCreateWithoutValidatedByInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  delete: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutValidatedByInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  deleteMany: [ProductScalarWhereInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutValidatedByInput!]
}

input ProductUpdateWithWhereUniqueWithoutCartsInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCartsDataInput!
}

input ProductUpdateWithWhereUniqueWithoutOrdersInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutOrdersDataInput!
}

input ProductUpdateWithWhereUniqueWithoutSubmittedByInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutSubmittedByDataInput!
}

input ProductUpdateWithWhereUniqueWithoutValidatedByInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutValidatedByDataInput!
}

input ProductUpdateWithoutCartsDataInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
  orders: OrderUpdateManyWithoutProductsInput
  submittedBy: UserUpdateOneWithoutProductsInput
  validatedBy: UserUpdateOneWithoutValidatedProductsInput
}

input ProductUpdateWithoutOrdersDataInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
  submittedBy: UserUpdateOneWithoutProductsInput
  validatedBy: UserUpdateOneWithoutValidatedProductsInput
  carts: CartUpdateManyWithoutProductsInput
}

input ProductUpdateWithoutSubmittedByDataInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
  orders: OrderUpdateManyWithoutProductsInput
  validatedBy: UserUpdateOneWithoutValidatedProductsInput
  carts: CartUpdateManyWithoutProductsInput
}

input ProductUpdateWithoutValidatedByDataInput {
  name: String
  price: Int
  status: ProductStatus
  description: String
  orders: OrderUpdateManyWithoutProductsInput
  submittedBy: UserUpdateOneWithoutProductsInput
  carts: CartUpdateManyWithoutProductsInput
}

input ProductUpsertWithWhereUniqueWithoutCartsInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCartsDataInput!
  create: ProductCreateWithoutCartsInput!
}

input ProductUpsertWithWhereUniqueWithoutOrdersInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutOrdersDataInput!
  create: ProductCreateWithoutOrdersInput!
}

input ProductUpsertWithWhereUniqueWithoutSubmittedByInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutSubmittedByDataInput!
  create: ProductCreateWithoutSubmittedByInput!
}

input ProductUpsertWithWhereUniqueWithoutValidatedByInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutValidatedByDataInput!
  create: ProductCreateWithoutValidatedByInput!
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  cart(where: CartSubscriptionWhereInput): CartSubscriptionPayload
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
}

input UserCreateInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  address: AddressCreateOneWithoutAssociatedUserInput
  orders: OrderCreateManyWithoutAssociatedUserInput
  products: ProductCreateManyWithoutSubmittedByInput
  validatedProducts: ProductCreateManyWithoutValidatedByInput
  cart: CartCreateOneWithoutRelatedUserInput
}

input UserCreateOneWithoutAddressInput {
  create: UserCreateWithoutAddressInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCartInput {
  create: UserCreateWithoutCartInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutProductsInput {
  create: UserCreateWithoutProductsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutValidatedProductsInput {
  create: UserCreateWithoutValidatedProductsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAddressInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  orders: OrderCreateManyWithoutAssociatedUserInput
  products: ProductCreateManyWithoutSubmittedByInput
  validatedProducts: ProductCreateManyWithoutValidatedByInput
  cart: CartCreateOneWithoutRelatedUserInput
}

input UserCreateWithoutCartInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  address: AddressCreateOneWithoutAssociatedUserInput
  orders: OrderCreateManyWithoutAssociatedUserInput
  products: ProductCreateManyWithoutSubmittedByInput
  validatedProducts: ProductCreateManyWithoutValidatedByInput
}

input UserCreateWithoutOrdersInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  address: AddressCreateOneWithoutAssociatedUserInput
  products: ProductCreateManyWithoutSubmittedByInput
  validatedProducts: ProductCreateManyWithoutValidatedByInput
  cart: CartCreateOneWithoutRelatedUserInput
}

input UserCreateWithoutProductsInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  address: AddressCreateOneWithoutAssociatedUserInput
  orders: OrderCreateManyWithoutAssociatedUserInput
  validatedProducts: ProductCreateManyWithoutValidatedByInput
  cart: CartCreateOneWithoutRelatedUserInput
}

input UserCreateWithoutValidatedProductsInput {
  id: ID
  username: String!
  roles: Role
  password: String!
  email: String!
  address: AddressCreateOneWithoutAssociatedUserInput
  orders: OrderCreateManyWithoutAssociatedUserInput
  products: ProductCreateManyWithoutSubmittedByInput
  cart: CartCreateOneWithoutRelatedUserInput
}

type UserPreviousValues {
  id: ID!
  username: String!
  roles: Role!
  password: String!
  email: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  # Logical AND on all given filters.
  AND: [UserSubscriptionWhereInput!]

  # Logical OR on all given filters.
  OR: [UserSubscriptionWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [UserSubscriptionWhereInput!]

  # The subscription event gets dispatched when it's listed in mutation_in
  mutation_in: [MutationType!]

  # The subscription event gets only dispatched when one of the updated fields names is included in this list
  updatedFields_contains: String

  # The subscription event gets only dispatched when all of the field names included in this list have been updated
  updatedFields_contains_every: [String!]

  # The subscription event gets only dispatched when some of the field names included in this list have been updated
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  username: String
  roles: Role
  password: String
  email: String
  address: AddressUpdateOneWithoutAssociatedUserInput
  orders: OrderUpdateManyWithoutAssociatedUserInput
  products: ProductUpdateManyWithoutSubmittedByInput
  validatedProducts: ProductUpdateManyWithoutValidatedByInput
  cart: CartUpdateOneWithoutRelatedUserInput
}

input UserUpdateManyMutationInput {
  username: String
  roles: Role
  password: String
  email: String
}

input UserUpdateOneWithoutAddressInput {
  create: UserCreateWithoutAddressInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateWithoutAddressDataInput
  upsert: UserUpsertWithoutAddressInput
}

input UserUpdateOneWithoutCartInput {
  create: UserCreateWithoutCartInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateWithoutCartDataInput
  upsert: UserUpsertWithoutCartInput
}

input UserUpdateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
}

input UserUpdateOneWithoutProductsInput {
  create: UserCreateWithoutProductsInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateWithoutProductsDataInput
  upsert: UserUpsertWithoutProductsInput
}

input UserUpdateOneWithoutValidatedProductsInput {
  create: UserCreateWithoutValidatedProductsInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserUpdateWithoutValidatedProductsDataInput
  upsert: UserUpsertWithoutValidatedProductsInput
}

input UserUpdateWithoutAddressDataInput {
  username: String
  roles: Role
  password: String
  email: String
  orders: OrderUpdateManyWithoutAssociatedUserInput
  products: ProductUpdateManyWithoutSubmittedByInput
  validatedProducts: ProductUpdateManyWithoutValidatedByInput
  cart: CartUpdateOneWithoutRelatedUserInput
}

input UserUpdateWithoutCartDataInput {
  username: String
  roles: Role
  password: String
  email: String
  address: AddressUpdateOneWithoutAssociatedUserInput
  orders: OrderUpdateManyWithoutAssociatedUserInput
  products: ProductUpdateManyWithoutSubmittedByInput
  validatedProducts: ProductUpdateManyWithoutValidatedByInput
}

input UserUpdateWithoutOrdersDataInput {
  username: String
  roles: Role
  password: String
  email: String
  address: AddressUpdateOneWithoutAssociatedUserInput
  products: ProductUpdateManyWithoutSubmittedByInput
  validatedProducts: ProductUpdateManyWithoutValidatedByInput
  cart: CartUpdateOneWithoutRelatedUserInput
}

input UserUpdateWithoutProductsDataInput {
  username: String
  roles: Role
  password: String
  email: String
  address: AddressUpdateOneWithoutAssociatedUserInput
  orders: OrderUpdateManyWithoutAssociatedUserInput
  validatedProducts: ProductUpdateManyWithoutValidatedByInput
  cart: CartUpdateOneWithoutRelatedUserInput
}

input UserUpdateWithoutValidatedProductsDataInput {
  username: String
  roles: Role
  password: String
  email: String
  address: AddressUpdateOneWithoutAssociatedUserInput
  orders: OrderUpdateManyWithoutAssociatedUserInput
  products: ProductUpdateManyWithoutSubmittedByInput
  cart: CartUpdateOneWithoutRelatedUserInput
}

input UserUpsertWithoutAddressInput {
  update: UserUpdateWithoutAddressDataInput!
  create: UserCreateWithoutAddressInput!
}

input UserUpsertWithoutCartInput {
  update: UserUpdateWithoutCartDataInput!
  create: UserCreateWithoutCartInput!
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserUpsertWithoutProductsInput {
  update: UserUpdateWithoutProductsDataInput!
  create: UserCreateWithoutProductsInput!
}

input UserUpsertWithoutValidatedProductsInput {
  update: UserUpdateWithoutValidatedProductsDataInput!
  create: UserCreateWithoutValidatedProductsInput!
}

type Address implements Node {
  id: ID!
  city: String!
  country: String!
  postalCode: String!
  state: String!
  streetAddress: String!
  additionalStreetAddress: String!
  associatedUser: User
}

# A connection to a list of items.
type AddressConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

# An edge in a connection.
type AddressEdge {
  # The item at the end of the edge.
  node: Address!

  # A cursor for use in pagination.
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  city_ASC
  city_DESC
  country_ASC
  country_DESC
  postalCode_ASC
  postalCode_DESC
  state_ASC
  state_DESC
  streetAddress_ASC
  streetAddress_DESC
  additionalStreetAddress_ASC
  additionalStreetAddress_DESC
}

input AddressWhereInput {
  # Logical AND on all given filters.
  AND: [AddressWhereInput!]

  # Logical OR on all given filters.
  OR: [AddressWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [AddressWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  city: String

  # All values that are not equal to given value.
  city_not: String

  # All values that are contained in given list.
  city_in: [String!]

  # All values that are not contained in given list.
  city_not_in: [String!]

  # All values less than the given value.
  city_lt: String

  # All values less than or equal the given value.
  city_lte: String

  # All values greater than the given value.
  city_gt: String

  # All values greater than or equal the given value.
  city_gte: String

  # All values containing the given string.
  city_contains: String

  # All values not containing the given string.
  city_not_contains: String

  # All values starting with the given string.
  city_starts_with: String

  # All values not starting with the given string.
  city_not_starts_with: String

  # All values ending with the given string.
  city_ends_with: String

  # All values not ending with the given string.
  city_not_ends_with: String

  #
  country: String

  # All values that are not equal to given value.
  country_not: String

  # All values that are contained in given list.
  country_in: [String!]

  # All values that are not contained in given list.
  country_not_in: [String!]

  # All values less than the given value.
  country_lt: String

  # All values less than or equal the given value.
  country_lte: String

  # All values greater than the given value.
  country_gt: String

  # All values greater than or equal the given value.
  country_gte: String

  # All values containing the given string.
  country_contains: String

  # All values not containing the given string.
  country_not_contains: String

  # All values starting with the given string.
  country_starts_with: String

  # All values not starting with the given string.
  country_not_starts_with: String

  # All values ending with the given string.
  country_ends_with: String

  # All values not ending with the given string.
  country_not_ends_with: String

  #
  postalCode: String

  # All values that are not equal to given value.
  postalCode_not: String

  # All values that are contained in given list.
  postalCode_in: [String!]

  # All values that are not contained in given list.
  postalCode_not_in: [String!]

  # All values less than the given value.
  postalCode_lt: String

  # All values less than or equal the given value.
  postalCode_lte: String

  # All values greater than the given value.
  postalCode_gt: String

  # All values greater than or equal the given value.
  postalCode_gte: String

  # All values containing the given string.
  postalCode_contains: String

  # All values not containing the given string.
  postalCode_not_contains: String

  # All values starting with the given string.
  postalCode_starts_with: String

  # All values not starting with the given string.
  postalCode_not_starts_with: String

  # All values ending with the given string.
  postalCode_ends_with: String

  # All values not ending with the given string.
  postalCode_not_ends_with: String

  #
  state: String

  # All values that are not equal to given value.
  state_not: String

  # All values that are contained in given list.
  state_in: [String!]

  # All values that are not contained in given list.
  state_not_in: [String!]

  # All values less than the given value.
  state_lt: String

  # All values less than or equal the given value.
  state_lte: String

  # All values greater than the given value.
  state_gt: String

  # All values greater than or equal the given value.
  state_gte: String

  # All values containing the given string.
  state_contains: String

  # All values not containing the given string.
  state_not_contains: String

  # All values starting with the given string.
  state_starts_with: String

  # All values not starting with the given string.
  state_not_starts_with: String

  # All values ending with the given string.
  state_ends_with: String

  # All values not ending with the given string.
  state_not_ends_with: String

  #
  streetAddress: String

  # All values that are not equal to given value.
  streetAddress_not: String

  # All values that are contained in given list.
  streetAddress_in: [String!]

  # All values that are not contained in given list.
  streetAddress_not_in: [String!]

  # All values less than the given value.
  streetAddress_lt: String

  # All values less than or equal the given value.
  streetAddress_lte: String

  # All values greater than the given value.
  streetAddress_gt: String

  # All values greater than or equal the given value.
  streetAddress_gte: String

  # All values containing the given string.
  streetAddress_contains: String

  # All values not containing the given string.
  streetAddress_not_contains: String

  # All values starting with the given string.
  streetAddress_starts_with: String

  # All values not starting with the given string.
  streetAddress_not_starts_with: String

  # All values ending with the given string.
  streetAddress_ends_with: String

  # All values not ending with the given string.
  streetAddress_not_ends_with: String

  #
  additionalStreetAddress: String

  # All values that are not equal to given value.
  additionalStreetAddress_not: String

  # All values that are contained in given list.
  additionalStreetAddress_in: [String!]

  # All values that are not contained in given list.
  additionalStreetAddress_not_in: [String!]

  # All values less than the given value.
  additionalStreetAddress_lt: String

  # All values less than or equal the given value.
  additionalStreetAddress_lte: String

  # All values greater than the given value.
  additionalStreetAddress_gt: String

  # All values greater than or equal the given value.
  additionalStreetAddress_gte: String

  # All values containing the given string.
  additionalStreetAddress_contains: String

  # All values not containing the given string.
  additionalStreetAddress_not_contains: String

  # All values starting with the given string.
  additionalStreetAddress_starts_with: String

  # All values not starting with the given string.
  additionalStreetAddress_not_starts_with: String

  # All values ending with the given string.
  additionalStreetAddress_ends_with: String

  # All values not ending with the given string.
  additionalStreetAddress_not_ends_with: String
  associatedUser: UserWhereInput
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateCart {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Cart implements Node {
  id: ID!
  price: Int!
  products(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product!]
  relatedUser: User
}

# A connection to a list of items.
type CartConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [CartEdge]!
  aggregate: AggregateCart!
}

# An edge in a connection.
type CartEdge {
  # The item at the end of the edge.
  node: Cart!

  # A cursor for use in pagination.
  cursor: String!
}

enum CartOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
}

input CartWhereInput {
  # Logical AND on all given filters.
  AND: [CartWhereInput!]

  # Logical OR on all given filters.
  OR: [CartWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [CartWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  relatedUser: UserWhereInput
}

input CartWhereUniqueInput {
  id: ID
}

scalar DateTime

# An object with an ID
interface Node {
  # The id of the object.
  id: ID!
}

type Order implements Node {
  id: ID!
  price: Int!
  date: DateTime!
  status: OrderStatus!
  associatedUser: User
  products(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product!]
}

# A connection to a list of items.
type OrderConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

# An edge in a connection.
type OrderEdge {
  # The item at the end of the edge.
  node: Order!

  # A cursor for use in pagination.
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  date_ASC
  date_DESC
  status_ASC
  status_DESC
}

enum OrderStatus {
  DELIVERED
  ORDERED
  CANCELLED
}

input OrderWhereInput {
  # Logical AND on all given filters.
  AND: [OrderWhereInput!]

  # Logical OR on all given filters.
  OR: [OrderWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [OrderWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int

  #
  date: DateTime

  # All values that are not equal to given value.
  date_not: DateTime

  # All values that are contained in given list.
  date_in: [DateTime!]

  # All values that are not contained in given list.
  date_not_in: [DateTime!]

  # All values less than the given value.
  date_lt: DateTime

  # All values less than or equal the given value.
  date_lte: DateTime

  # All values greater than the given value.
  date_gt: DateTime

  # All values greater than or equal the given value.
  date_gte: DateTime

  #
  status: OrderStatus

  # All values that are not equal to given value.
  status_not: OrderStatus

  # All values that are contained in given list.
  status_in: [OrderStatus!]

  # All values that are not contained in given list.
  status_not_in: [OrderStatus!]
  associatedUser: UserWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
}

input OrderWhereUniqueInput {
  id: ID
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Product implements Node {
  id: ID!
  name: String!
  price: Int!
  status: ProductStatus
  orders(
    where: OrderWhereInput
    orderBy: OrderOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Order!]
  submittedBy: User
  validatedBy: User
  description: String!
  carts(
    where: CartWhereInput
    orderBy: CartOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Cart!]
}

# A connection to a list of items.
type ProductConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

# An edge in a connection.
type ProductEdge {
  # The item at the end of the edge.
  node: Product!

  # A cursor for use in pagination.
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  status_ASC
  status_DESC
  description_ASC
  description_DESC
}

enum ProductStatus {
  VERIFIED
  TO_REVIEW
  DENIED
}

input ProductWhereInput {
  # Logical AND on all given filters.
  AND: [ProductWhereInput!]

  # Logical OR on all given filters.
  OR: [ProductWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [ProductWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  name: String

  # All values that are not equal to given value.
  name_not: String

  # All values that are contained in given list.
  name_in: [String!]

  # All values that are not contained in given list.
  name_not_in: [String!]

  # All values less than the given value.
  name_lt: String

  # All values less than or equal the given value.
  name_lte: String

  # All values greater than the given value.
  name_gt: String

  # All values greater than or equal the given value.
  name_gte: String

  # All values containing the given string.
  name_contains: String

  # All values not containing the given string.
  name_not_contains: String

  # All values starting with the given string.
  name_starts_with: String

  # All values not starting with the given string.
  name_not_starts_with: String

  # All values ending with the given string.
  name_ends_with: String

  # All values not ending with the given string.
  name_not_ends_with: String

  #
  price: Int

  # All values that are not equal to given value.
  price_not: Int

  # All values that are contained in given list.
  price_in: [Int!]

  # All values that are not contained in given list.
  price_not_in: [Int!]

  # All values less than the given value.
  price_lt: Int

  # All values less than or equal the given value.
  price_lte: Int

  # All values greater than the given value.
  price_gt: Int

  # All values greater than or equal the given value.
  price_gte: Int

  #
  status: ProductStatus

  # All values that are not equal to given value.
  status_not: ProductStatus

  # All values that are contained in given list.
  status_in: [ProductStatus!]

  # All values that are not contained in given list.
  status_not_in: [ProductStatus!]

  #
  description: String

  # All values that are not equal to given value.
  description_not: String

  # All values that are contained in given list.
  description_in: [String!]

  # All values that are not contained in given list.
  description_not_in: [String!]

  # All values less than the given value.
  description_lt: String

  # All values less than or equal the given value.
  description_lte: String

  # All values greater than the given value.
  description_gt: String

  # All values greater than or equal the given value.
  description_gte: String

  # All values containing the given string.
  description_contains: String

  # All values not containing the given string.
  description_not_contains: String

  # All values starting with the given string.
  description_starts_with: String

  # All values not starting with the given string.
  description_not_starts_with: String

  # All values ending with the given string.
  description_ends_with: String

  # All values not ending with the given string.
  description_not_ends_with: String
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  submittedBy: UserWhereInput
  validatedBy: UserWhereInput
  carts_every: CartWhereInput
  carts_some: CartWhereInput
  carts_none: CartWhereInput
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  users(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [User]!
  products(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product]!
  orders(
    where: OrderWhereInput
    orderBy: OrderOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Order]!
  carts(
    where: CartWhereInput
    orderBy: CartOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Cart]!
  addresses(
    where: AddressWhereInput
    orderBy: AddressOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Address]!
  user(where: UserWhereUniqueInput!): User
  product(where: ProductWhereUniqueInput!): Product
  order(where: OrderWhereUniqueInput!): Order
  cart(where: CartWhereUniqueInput!): Cart
  address(where: AddressWhereUniqueInput!): Address
  usersConnection(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  productsConnection(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): ProductConnection!
  ordersConnection(
    where: OrderWhereInput
    orderBy: OrderOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): OrderConnection!
  cartsConnection(
    where: CartWhereInput
    orderBy: CartOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): CartConnection!
  addressesConnection(
    where: AddressWhereInput
    orderBy: AddressOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): AddressConnection!

  # Fetches an object given its ID
  node(
    # The ID of an object
    id: ID!
  ): Node
}

enum Role {
  ROLE_USER
  ROLE_SELLER
  ROLE_ADMIN
}

type User implements Node {
  id: ID!
  username: String!
  roles: Role!
  password: String!
  email: String!
  address: Address
  orders(
    where: OrderWhereInput
    orderBy: OrderOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Order!]
  products(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product!]
  validatedProducts(
    where: ProductWhereInput
    orderBy: ProductOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Product!]
  cart: Cart
}

# A connection to a list of items.
type UserConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

# An edge in a connection.
type UserEdge {
  # The item at the end of the edge.
  node: User!

  # A cursor for use in pagination.
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  roles_ASC
  roles_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
}

input UserWhereInput {
  # Logical AND on all given filters.
  AND: [UserWhereInput!]

  # Logical OR on all given filters.
  OR: [UserWhereInput!]

  # Logical NOT on all given filters combined by AND.
  NOT: [UserWhereInput!]

  #
  id: ID

  # All values that are not equal to given value.
  id_not: ID

  # All values that are contained in given list.
  id_in: [ID!]

  # All values that are not contained in given list.
  id_not_in: [ID!]

  # All values less than the given value.
  id_lt: ID

  # All values less than or equal the given value.
  id_lte: ID

  # All values greater than the given value.
  id_gt: ID

  # All values greater than or equal the given value.
  id_gte: ID

  # All values containing the given string.
  id_contains: ID

  # All values not containing the given string.
  id_not_contains: ID

  # All values starting with the given string.
  id_starts_with: ID

  # All values not starting with the given string.
  id_not_starts_with: ID

  # All values ending with the given string.
  id_ends_with: ID

  # All values not ending with the given string.
  id_not_ends_with: ID

  #
  username: String

  # All values that are not equal to given value.
  username_not: String

  # All values that are contained in given list.
  username_in: [String!]

  # All values that are not contained in given list.
  username_not_in: [String!]

  # All values less than the given value.
  username_lt: String

  # All values less than or equal the given value.
  username_lte: String

  # All values greater than the given value.
  username_gt: String

  # All values greater than or equal the given value.
  username_gte: String

  # All values containing the given string.
  username_contains: String

  # All values not containing the given string.
  username_not_contains: String

  # All values starting with the given string.
  username_starts_with: String

  # All values not starting with the given string.
  username_not_starts_with: String

  # All values ending with the given string.
  username_ends_with: String

  # All values not ending with the given string.
  username_not_ends_with: String

  #
  roles: Role

  # All values that are not equal to given value.
  roles_not: Role

  # All values that are contained in given list.
  roles_in: [Role!]

  # All values that are not contained in given list.
  roles_not_in: [Role!]

  #
  password: String

  # All values that are not equal to given value.
  password_not: String

  # All values that are contained in given list.
  password_in: [String!]

  # All values that are not contained in given list.
  password_not_in: [String!]

  # All values less than the given value.
  password_lt: String

  # All values less than or equal the given value.
  password_lte: String

  # All values greater than the given value.
  password_gt: String

  # All values greater than or equal the given value.
  password_gte: String

  # All values containing the given string.
  password_contains: String

  # All values not containing the given string.
  password_not_contains: String

  # All values starting with the given string.
  password_starts_with: String

  # All values not starting with the given string.
  password_not_starts_with: String

  # All values ending with the given string.
  password_ends_with: String

  # All values not ending with the given string.
  password_not_ends_with: String

  #
  email: String

  # All values that are not equal to given value.
  email_not: String

  # All values that are contained in given list.
  email_in: [String!]

  # All values that are not contained in given list.
  email_not_in: [String!]

  # All values less than the given value.
  email_lt: String

  # All values less than or equal the given value.
  email_lte: String

  # All values greater than the given value.
  email_gt: String

  # All values greater than or equal the given value.
  email_gte: String

  # All values containing the given string.
  email_contains: String

  # All values not containing the given string.
  email_not_contains: String

  # All values starting with the given string.
  email_starts_with: String

  # All values not starting with the given string.
  email_not_starts_with: String

  # All values ending with the given string.
  email_ends_with: String

  # All values not ending with the given string.
  email_not_ends_with: String
  address: AddressWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  validatedProducts_every: ProductWhereInput
  validatedProducts_some: ProductWhereInput
  validatedProducts_none: ProductWhereInput
  cart: CartWhereInput
}

input UserWhereUniqueInput {
  id: ID
}

# The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
scalar Long
